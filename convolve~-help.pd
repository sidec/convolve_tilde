#N canvas 247 145 993 613 10;
#N canvas 641 50 703 396 init 0;
#X obj 246 318 soundfiler;
#X msg 357 133 \; \$1-dry-volume-set 0 \; \$1-wet-volume-set 0 \; \$1-master-volume-set
0 \;;
#X obj 357 113 f \$0;
#X obj 407 38 f \$0;
#X obj 46 58 loadbang;
#X obj 23 79 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 46 190 s \$0-lb4;
#X obj 46 79 t b b b b;
#X obj 136 130 s \$0-lb1;
#X obj 106 150 s \$0-lb2;
#X obj 76 170 s \$0-lb3;
#X obj 246 27 r \$0-lb2;
#X msg 246 208 read -resize ./audio/ir-large-chamber.wav \$1-largeChamber
;
#X msg 286 228 read -resize ./audio/ir-tunnel.wav \$1-tunnel;
#X msg 326 248 read -resize ./audio/ir-tam.wav \$1-tamTam;
#X msg 366 268 read -resize ./audio/ir-cym.wav \$1-cymbal;
#X obj 246 159 f \$0;
#X obj 246 180 t f f f f;
#X obj 246 48 t b b b;
#X msg 407 58 \; \$1-24-band-eq const 1 \; \$1-eq-scalars const 1 \;
;
#X connect 2 0 1 0;
#X connect 3 0 19 0;
#X connect 4 0 7 0;
#X connect 5 0 7 0;
#X connect 7 0 6 0;
#X connect 7 1 10 0;
#X connect 7 2 9 0;
#X connect 7 3 8 0;
#X connect 11 0 18 0;
#X connect 12 0 0 0;
#X connect 13 0 0 0;
#X connect 14 0 0 0;
#X connect 15 0 0 0;
#X connect 16 0 17 0;
#X connect 17 0 12 0;
#X connect 17 1 13 0;
#X connect 17 2 14 0;
#X connect 17 3 15 0;
#X connect 18 0 16 0;
#X connect 18 1 2 0;
#X connect 18 2 3 0;
#X restore 301 90 pd init;
#X floatatom 361 348 5 0 0 0 - #0-master-volume -, f 5;
#X obj 110 91 readsf~;
#X msg 132 62 stop;
#X obj 34 55 *~;
#X obj 34 126 +~;
#X obj 64 55 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0 1
;
#X obj 158 246 env~;
#X floatatom 158 267 5 0 0 1 dB - -, f 5;
#X obj 224 348 hsl 128 15 0 100 0 0 \$0-master-volume \$0-master-volume-set
master-volume 8 8 0 12 -228856 -1 -1 0 1;
#X obj 481 37 cnv 15 400 220 empty empty empty 20 12 0 14 -233017 -66577
0;
#X obj 481 352 cnv 15 220 220 empty empty empty 20 12 0 14 -233017
-66577 0;
#X text 490 360 Try these different IRs;
#X floatatom 361 328 5 0 0 0 - #0-wet-volume -, f 5;
#X obj 224 328 hsl 128 15 0 100 0 0 \$0-wet-volume \$0-wet-volume-set
wet-volume 8 8 0 12 -228856 -1 -1 0 1;
#X floatatom 361 308 5 0 0 0 - #0-dry-volume -, f 5;
#X obj 224 308 hsl 128 15 0 100 0 0 \$0-dry-volume \$0-dry-volume-set
dry-volume 8 8 0 12 -228856 -1 -1 0 1;
#N canvas 190 207 521 438 mix-dry-and-wet 0;
#X obj 46 24 inlet~;
#X obj 46 364 outlet~;
#X obj 46 289 *~;
#X obj 346 247 dbtorms;
#X obj 346 289 line~;
#X obj 346 268 pack f 40;
#X obj 46 159 *~;
#X obj 96 117 dbtorms;
#X obj 96 159 line~;
#X obj 96 138 pack f 40;
#X obj 46 230 +~;
#X obj 236 24 inlet~;
#X obj 236 159 *~;
#X obj 286 117 dbtorms;
#X obj 286 159 line~;
#X obj 286 138 pack f 40;
#X obj 96 96 r \$0-dry-volume;
#X obj 286 96 r \$0-wet-volume;
#X obj 346 226 r \$0-master-volume;
#X connect 0 0 6 0;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 4 0 2 1;
#X connect 5 0 4 0;
#X connect 6 0 10 0;
#X connect 7 0 9 0;
#X connect 8 0 6 1;
#X connect 9 0 8 0;
#X connect 10 0 2 0;
#X connect 11 0 12 0;
#X connect 12 0 10 1;
#X connect 13 0 15 0;
#X connect 14 0 12 1;
#X connect 15 0 14 0;
#X connect 16 0 7 0;
#X connect 17 0 13 0;
#X connect 18 0 3 0;
#X restore 34 302 pd mix-dry-and-wet;
#N canvas 0 23 487 359 cpu-meter 0;
#X floatatom 103 122 5 0 0 1 % - -, f 5;
#X obj 272 158 cputime;
#X obj 272 102 metro 1000;
#X msg 272 66 1;
#X obj 272 130 t b b;
#X obj 272 218 * 0.1;
#X obj 272 187 int;
#X obj 272 38 r \$0-lb1;
#X connect 1 0 6 0;
#X connect 2 0 4 0;
#X connect 3 0 2 0;
#X connect 4 0 1 0;
#X connect 4 1 1 1;
#X connect 5 0 0 0;
#X connect 6 0 5 0;
#X connect 7 0 3 0;
#X coords 0 -1 1 1 85 40 1 100 100;
#X restore 731 280 pd cpu-meter;
#X obj 159 158 r \$0-convolve;
#X obj 513 548 s \$0-convolve;
#X text 479 313 William Brent \, March 2018;
#X obj 4 4 cnv 10 400 10 empty empty empty 20 12 0 14 -233017 -66577
0;
#X obj 4 4 cnv 10 10 400 empty empty empty 20 12 0 14 -233017 -66577
0;
#X obj 731 352 cnv 15 220 220 empty empty empty 20 12 0 14 -233017
-66577 0;
#X obj 753 539 s \$0-convolve;
#X msg 793 503 window 64;
#X msg 773 473 window 1920;
#N canvas 740 104 913 453 partitioned-convolution-explained 0;
#X text 38 177 This is the standard frequency domain method \, which
is much faster than performing convolution in the time domain. In either
case \, the result is that a scaled and time shifted copy of one file
takes the place of every single sample in the other. So \, if you have
an impulse response (IR) of a room - that is \, a burst of noise followed
by the natural echos the room produces - you can graft that pattern
of echos onto every single sample in your input file.;
#X text 38 297 With real-time input \, the situation becomes more complicated.
We can have an IR prepared in advance \, but the other sound source
only shows up bit by bit. Typically \, it will arrive in chunks of
64 \, 128 \, 256 \, or some other number of samples. Partitioned convolution
solves this problem by breaking up the IR into some number of partitions
that is each M samples long. M should be the same size as the chunks
of input that arrive in real time. Then \, each of the partitions is
Fourier transformed and stored as frequency domain data.;
#X text 488 247 The last point to make is that the size of the Fourier
transform must be M*2. That is \, when we get the latest M samples
\, we pad it out with zeros to M*2 samples \, then transform it. All
of the IR partitions are padded to this same size. When any one chunk
is inverse Fourier transformed \, its main content will be over the
first M samples \, trailed by low amplitude samples or zeros. A process
of overlapping and adding is then performed so that the first M samples
of the most recently processed M*2 samples is mixed down with the last
M samples of the previous chunk of processed M*2 samples.;
#X text 488 27 When each new input chunk arrives (the M most recent
samples) \, it is Fourier transformed into complex frequency domain
data. The new chunk of frequency domain data is multiplied against
each of the pre-prepared IR partitions that are also in the frequency
domain. We can immediately do an inverse Fourier transform on the most
recently available chunk to hear that portion of the processed input
in the time domain \, but the other chunks will wait in a buffer to
be output in the future. The crucial point to understand is that as
new input chunks come in and are transformed and multiplied in the
frequency domain \, we sum that new data with whatever other frequency
domain data was waiting in that part of the buffer. Thus \, we save
numerous FFT calls by summing in the frequency domain.;
#X text 38 27 With two pre-recorded sound files \, convolution is pretty
simple. We determine which file is longer \, find the next highest
power of 2 (we'll call it N) \, and then pad each of the files with
addiontal zeros up to N. Next \, we do a forward Fourier transform
on each of them \, and multiply the transformed data sets point by
point. Because the data contain complex values \, we must do a complex
multiply vis FOIL. After multiplication \, all that is left to do is
an inverse Fourier transform on the frequency domain product. Depending
on the specific FFT algorithm being used \, you may also have to scale
the amplitude by the reciprocal of N.;
#X restore 481 267 pd partitioned-convolution-explained;
#X text 218 374 ** Beware of hot output!! **;
#X text 728 326 Small partition sizes are expensive, f 36;
#X text 490 51 [convolve~] is a partitioned impulse response (IR) convolution
object. The only creation argument is the partition size \, which also
determines the amount of delay between the dry and wet signal (i.e.
\, pre-delay). Partition size must be a multiple of Pd's default block
size: 64 samples (1.4512ms @ 44100Hz).;
#N canvas 196 114 478 429 24-band-gain-scalars 0;
#N canvas 563 354 757 338 write-bands-to-scalar-array 0;
#X obj 29 139 list prepend eq;
#X obj 29 160 list trim;
#X obj 29 181 s \$0-convolve;
#X obj 29 118 array get \$0-eq-scalars;
#N canvas 698 262 459 234 load-bark-bounds 0;
#X obj 28 54 f \$0;
#X msg 28 75 \; \$1-bark-bounds 0 0 100.464 203.724 312.657 430.295
559.913 705.121 869.96 1059.02 1277.57 1531.68 1828.45 2176.12 2584.37
3064.59 3630.12 4296.73 5082.97 6010.73 7105.83 8398.79 9925.58 11728.7
13858.4 22050 \; \$1-bark-bounds bounds 0 22050 24 0 \;;
#X obj 28 33 r \$0-lb1;
#X connect 0 0 1 0;
#X connect 2 0 0 0;
#X restore 228 108 pd load-bark-bounds;
#X obj 228 128 table \$0-bark-bounds 25;
#X obj 29 32 r \$0-send-eq-list;
#X obj 451 158 metro 100;
#X obj 451 179 s \$0-update-eq;
#X text 30 224 Here \, we dump the eq-scalar values out of the table
and send them to [convolve~] as an "eq" message. Since working in linear
frequency bins isn't very intuitive \, we'll use the Bark frequency
scale to define 24 frequency bands and have each of the values in the
24-band-eq table control a whole range of bins. The bandEqWriter.pd
abstraction does this job., f 81;
#X obj 451 116 r \$0-lb4;
#X obj 228 68 clone ./lib/bandEqWriter 24 \$0 44100 1280;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 3 0 0 0;
#X connect 6 0 3 0;
#X connect 7 0 8 0;
#X connect 10 0 7 0;
#X restore 41 159 pd write-bands-to-scalar-array;
#N canvas 612 404 685 397 eq-table-resizing 0;
#X obj 326 142 pack f \$0;
#X obj 276 50 route window;
#X obj 276 92 t b f;
#X obj 276 29 r \$0-convolve;
#X obj 276 71 + 1;
#X obj 147 48 inlet;
#X obj 68 164 inlet;
#X msg 68 329 \; \$1-24-band-eq const 0 \;;
#X obj 68 309 f \$0;
#X msg 147 263 \; \$1-24-band-eq const 1 \;;
#X obj 147 243 f \$0;
#X msg 326 163 \; \$2-eq-scalars resize \$1 \; \$2-eq-scalars const
1 \;;
#X text 374 26 When window size changes \, the size of the eq-scalars
array needs to change too. Because of internal zero padding \, the
analysis window size is actually double the partition size. For a requested
window size of N \, the actual analysis window size is N*2 \, and there
are N+1 frequency bins for frequencies 0 through Nyquist. So we need
N+1 eq scalars., f 49;
#X text 314 224 Internally \, [convolve~]'s eq scalars are set back
to 1 on every window size change \, so we should reset the eq-scalars
array and the 24-band-eq array to 1 as well., f 50;
#X connect 0 0 11 0;
#X connect 1 0 4 0;
#X connect 2 0 10 0;
#X connect 2 1 0 0;
#X connect 3 0 1 0;
#X connect 4 0 2 0;
#X connect 5 0 10 0;
#X connect 6 0 8 0;
#X connect 8 0 7 0;
#X connect 10 0 9 0;
#X restore 279 139 pd eq-table-resizing;
#X obj 279 159 table \$0-eq-scalars 641;
#X obj 345 17 bng 15 250 50 0 empty empty unity 17 7 0 10 -262144 -1
-1;
#X obj 275 17 bng 15 250 50 0 empty empty mute 17 7 0 12 -262144 -1
-1;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-24-band-eq 24 float 2;
#X coords 0 1.25 24 0 355 64 1 0 0;
#X restore 42 54 graph;
#X text 39 288 Here \, things are complicated further to make a more
user-friendly interface. The 24-band-eq array above is used to control
the eq scalars for all bins within each of 24 bands according to the
Bark scale. See inside the [pd write-bands-to-scalar-array] subpatch
for more details., f 67;
#X text 39 358 Note that scalar values below 0 are clipped to 0 \,
but there is no upper limit for scalars. Also note that you can get
distortion if the data in the eq-scalars table has large discontinuities.
, f 67;
#X text 39 189 As of version 0.1o \, you can scale the complex frequency-domain
values of the partitioned IR analysis via an "eq" message. This allows
you to boost or attenuate energy in any frequency bin. The "eq" method
expects a list of numbers that is one larger than the current partition
size. Since that's usually hundreds of numbers \, it's best to store
the eq scalars in a table and dump the data into a list using [array
get]., f 67;
#X connect 3 0 1 1;
#X connect 4 0 1 0;
#X coords 0 -1 1 1 380 120 1 30 10;
#X restore 34 452 pd 24-band-gain-scalars;
#X msg 110 40 open ../doc/sound/voice.wav \, start;
#X obj 301 224 cnv 15 150 60 empty empty empty 20 12 0 14 -233017 -66577
0;
#X text 310 232 Other messages;
#N canvas 550 54 533 262 other-messages 0;
#X obj 54 158 s \$0-convolve;
#X msg 54 62 flush;
#X msg 74 112 print;
#X text 136 111 Print internal settings to the post window;
#X text 116 61 Flush all internal buffer contents;
#X connect 1 0 0 0;
#X connect 2 0 0 0;
#X restore 312 256 pd other-messages;
#X text 740 360 Change window/partition size (and therefore delay)
in samples. Window sizes do not need to be powers of two \, but they
must be multiples of Pd's default block size (64)., f 31;
#X text 490 131 To start \, you must send [convolve~] an "analyze"
message specifying the name of the table where your IR is stored. Then
you can play back the example voice.wav \, or listen to live input
(with headphones to prevent feedback). The gain scaling hasn't been
worked out yet \, so you'll have to find the right volume attenuation
for your particular IR.;
#X text 490 211 It's ok to analyze different IRs and change window
size on the fly \, although audio will be interrupted.;
#X obj 493 383 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 513 383 f \$0;
#X msg 513 403 analyze \$1-largeChamber;
#X msg 513 443 analyze \$1-tunnel;
#X msg 513 483 analyze \$1-tamTam;
#X msg 513 523 analyze \$1-cymbal;
#X obj 301 111 table \$0-largeChamber;
#X obj 301 132 table \$0-tunnel;
#X obj 301 153 table \$0-tamTam;
#X obj 301 174 table \$0-cymbal;
#X obj 493 423 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 513 423 f \$0;
#X obj 493 463 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 513 463 f \$0;
#X obj 493 503 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 513 503 f \$0;
#X msg 753 443 window 320;
#X obj 139 208 convolve~ 640;
#X obj 34 351 dac~;
#X obj 34 34 adc~;
#X text 32 430 Version 0.1o has a new "eq" method;
#X text 479 293 [convolve~] version 0.1o;
#X connect 2 0 5 1;
#X connect 2 1 33 0;
#X connect 3 0 2 0;
#X connect 4 0 5 0;
#X connect 5 0 17 0;
#X connect 5 0 57 0;
#X connect 6 0 4 1;
#X connect 7 0 8 0;
#X connect 17 0 58 0;
#X connect 17 0 58 1;
#X connect 19 0 57 0;
#X connect 26 0 25 0;
#X connect 27 0 25 0;
#X connect 33 0 2 0;
#X connect 40 0 41 0;
#X connect 41 0 42 0;
#X connect 42 0 20 0;
#X connect 43 0 20 0;
#X connect 44 0 20 0;
#X connect 45 0 20 0;
#X connect 50 0 51 0;
#X connect 51 0 43 0;
#X connect 52 0 53 0;
#X connect 53 0 44 0;
#X connect 54 0 55 0;
#X connect 55 0 45 0;
#X connect 56 0 25 0;
#X connect 57 0 7 0;
#X connect 57 0 17 1;
#X connect 59 0 4 0;
